#최소 동작 사이트 구축

> 목표: 5장 마지막에서 발견한 문제점 해결

###기능 테스트 내에서 테스트 격리

이제부터 장고의 LiveServerTestCase 클래스를 이용하면 된다. 이는 유닛테스트 처럼 자동으로 테스트용 데이터베이스를 생성하고 서버를 가동한다. 몇 가지 제한사항이 있어서 별도 작업이 필요하지만 이 단계에선 유용한 툴이다.

기존 functional_test.py파일을  신규 functional_test 폴더 하위에 tests.py로 옯긴다. 기능테스트를 별도의 앱으로 구성한 것은 전역으로 여러 앱에 적용할 수 있기 때문이다. 이후 기능테스트 시행시 `$ python3 manage.py test functional_tests`로 실행한다.

NewVisitorTest의 상속자 클래스를 `LiveServerTestCase`로 바꾼다. 다음으로 포트 8000번을 이용한 로컬 호스트 접속을 하드코딩하는 대신 `LiveServerTestCase`가 제공하는 `live_server_url` 속성을 이용하도록 변경한다.

```{.python}
# functional_tests/tests.py

def test_can_start_a_list_and_retrieve_it_later(self):
	# 에디스(Edith)는 멋진 작업 목록 온라인 앱이 나왔다는 소식을 듣고
	# 해당 웹 사이트를 확인하러 간다
	self.browser.get(self.live_server_url)
```
맨 밑줄에 있는 `if \_\_name\_\_ == '\_\_main\_\_'을 지워도 된다. 기능테스트를 실행하기 위해 장고 테스트 실행자를 사용하기 때문이다.

이제 `$ manage.py test`를 실행하면 기능 테스트와 단위 테스트를 둘 다 실행하게 된다. 단위 테스트만 실행하려면 실행대상이 될 앱을 지정해주면 된다. `$manage.py test lists`

 우리가 해야할 것은 시스템 확장을 통해 각 사용자가 만든 목록을 서로 보지못하도록 해야 한다. 그리고 각 사용자는 자신의 개별 URL을 통해 자신이 저장한 목록에 접근 할 수 있어야 한다.

---
###필요한 경우에는 최소한의 설계를

> TDD는 긴 설계 과정 대신에, "동작하는 최소한의 어플리케이션"을 빠르게 만들고, 사용자 의견을 점진적으로 반영해가는 방식이다. 하지만 이것이 설계에 대해 생각하지 않아도 된다는 뜻은 아니다.

 - 각 사용자가 개별 목록을 저장하도록 한다.(지금은 최소 하나의 목록을 유지할 수 있도록 한다.)
 - 하나의 목록은 여러 개의 작업 아이템으로 구성된다. 각 내용은 텍스트이다.
 - 다음 방문 시에도 목록을 확인할 수 있어야 한다. 현 시점에선 각 목록에 해당하는 개별 URL을 사용자에게 제공한다. 이후에 사용자를 자동 인식하여 목록을 보여주도록 수정할 필요가 있다.

#####YAGNI!
야그니(You ain't gonna need it)는 애자일 복음이다. 아이디어가 정말 끝내주더라도 대개는 그걸 사용하지 않고 끝나는 경우가 많다. 되레 복잡성이 증가하기만 할 수도 있다. 야그니는 창의적이지만 과도한 열정을 억제해주는 경전이라고 할 수 있다.

#####REST
웹 설계 방법 중 하나다. 데이터 구조를 URL 구조에 일치시키는 방식이다. 우리 앱에서 각 목록은 다음과 같이 개별 URL을 가진다.
 - `/lists/<목록 식별자>/`

새로운 목록을 만드려면 다음과 같은 특별한 URL을 사용해서 POST요청을 한다.
 - `/lists/new`

기존 목록에 새로운 작업 아이템을 추가하려면, POST 요청을 보낼 수 있는 별도 URL을 사용한다.(여기선 REST 규칙을 완벽히 따르지 않는다)
 - `/lists/<목록 식별자>/add_item`


**작업 메모장**을 다음과 같이 정리할 수 있다.
 - ~~기능 테스트가 끝난 후에 결과물을 제거한다~~
 - 모델을 조정해서 아이템들이 달ㄴ 목록과 연계되도록 한다.
 - 각 목록별 고유 URL을 추가한다.
 - POST를 이용해서 새로운 목록을 생성하는 URL을 추가한다.
 - POST를 이용해서 새로운 아이템을 기존 목록에 추가하는 URL을 만든다.

---
###TDD를 이용한 새로운 설계 반영하기

앞서 기술한 새로운 설계 내용을 기능 테스트를 반영해본다. inputbox.send_keys('공작깃털 사기') 부분을 찾아서 다음 코드 블록을 추가한다.
```{.python}
# functional_tests/test.py 

	# 엔터키를 누르면 새로운 URL로 바뀐다. 그리고 작업 목록에
	# "1: 공작깃털 사기" 아이템이 추가된다
	inputbox.send_keys(Keys.ENTER)
	edith_list_url = self.browser.corrent_url 
	self.assertRegex(edith_list_url, 'lists/.+')
	self.check_for_row_in_list_table('1: 공작깃털 사기')

	# 추가 아이템을 입력할 수 있는 텍스트 상자가 아직 존재한다
	...
``` 
이후 새로운 사용자인 프란시스가 어플리케이션을 이용한다는 가정하에 기능 테스트 시나리오를 수정한다.

---
###새로운 설계를 위한 반복

모델 변경이 필요므로 기존 기능 테스트 코드를 절반이상 뜯어 고쳐야 한다. **"This is TDD!!!"**

우선 기능 테스트가 두번째 아이템에 개별 URL과 식별자를 적용해야 한다고 말해주고 있다.

이상한 코드지만 우리는 한번에 하나씩 해결하기로 이미 동의했다.
```{.python}
# lists/tests.py 

self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')


# lists/views.py 

def home_page(request):
	if request.method == 'POST':
		# code...
		return redirect('/lists/the-only-list-in-the-world/')
	# code...
```
이제 특수한 URL을 구축해야한다.
---
###장고 테스트 클라이언트를 이용한 뷰, 템플릿, URL 동시 테스트

#####새로운 테스트 클래스

 - TestCase 속성인 `self.client.get( ... )` 사용
 - `assertIn/response.content.decode()` 대신 `assertContains` 메소드 사용

#####신규 URL

 - url 표기시 마지막에 붙이는 꼬리 슬래시에 주의한다. 버그의 원인이 된다.

#####신규 뷰 함수

 - 일단 home_page뷰 코드 2줄을 복붙한다.

#####그린? 아니면 리팩터?

그린 과정에 이르렀으니 리팩터링으로 들어왔다. 현재 두개의 뷰가 있고, 모든 작업 아이템을 템플릿에 전달하고 있다. ListViewTest 자체와 HomePageTest의 test_home_page_display_all_list_items가 중복된다.
명확히 하기 위해 HomePageTest의 해당 테스트를 삭제한다. 이제 메인페이지는 입력상자만 있으면 된다.

#####목록 출력을 위한 별도 템플릿

```{.python}
# lists/tests.py 

class ListViewTest(TestCase):

	def test_uses_list_template(self):
		response = self.client.get('/lists/the-only-list-in-the-world/')
		self.assertTemplateUsed(response, 'list.html')
```

실패후 뷰에서 템플릿을 수정한다. 당연히 또 실패한다. 빈 템플릿을 만들고 다시 실패한다. home.html을 복사해서 수정해간다. form에 action속성으로 "/"를 주고 기능테스트를 실행하면 url 유일성 테스트에서 오류가 날것이다.

---
###목록 아이템을 추가하기 위한 URL과 뷰

 - ~~기능 테스트가 끝난 후에 결과물을 제거한다~~
 - 모델을 조정해서 아이템들이 다른 모곡과 연계되도록 한다
 - 각 목록별 고유 URL을 추가한다
 - POST를 이용해서 새로운 목록을 생성하는 URL을 추가한다
 - POST를 이용해서 새로운 아이템을 기존 목록에 추가하는 URL을 만든다

세번째를 마쳤다고 친다..(?????) 두번째는 무서워보이니 네, 다섯번째를 먼저 진행한다.

#####신규 목록 생성을 위한 테스트 클래스

`lists/tests.py`에서 test_home_page_can_save_a_POST_request와 test_home_page_redirects_after_POST 메소드를 ListViewTest로 이동한다.

앞장에서(81page) 아이템 카운트와 응답코드 테스트를 분리한 덕에 쉽게 디버깅할 수 있게 됐다.

#####신규 목록 생성을 위한 URL과 뷰

신규 URL 및 view 설정 후(당연히 에러를 몇번 겪는다) home_page뷰에서 코드를 빌려쓴다.

예상치 못한 두번째 오류가 난다고 되어있으나, 잘된다...(?)

#####필요 없는 코드와 테스트 삭제

홈 뷰를 단순화 한다. 다른 뷰가 기능을 대체해주기 때문이다. 그리고나서 test_home_page_only_saves_items_when_necessary 테스트를 삭제한다.

 - ~~기능 테스트가 끝난 후에 결과물을 제거한다~~
 - 모델을 조정해서 아이템들이 다른 모곡과 연계되도록 한다
 - 각 목록별 고유 URL을 추가한다
 - ~~POST를 이용해서 새로운 목록을 생성하는 URL을 추가한다~~
 - POST를 이용해서 새로운 아이템을 기존 목록에 추가하는 URL을 만든다

---
###모델 조정하기

테스트를 뜯은후 List모델을 생성한다. 외래키 설정 후 테스트를 진행한다. 괴롭지만 한단계씩 한단계씩 진행한다...
 - ~~기능 테스트가 끝난 후에 결과물을 제거한다~~
 - ~~모델을 조정해서 아이템들이 다른 모곡과 연계되도록 한다~~
 - 각 목록별 고유 URL을 추가한다
 - ~~POST를 이용해서 새로운 목록을 생성하는 URL을 추가한다~~
 - POST를 이용해서 새로운 아이템을 기존 목록에 추가하는 URL을 만든다

---
###각 목록이 하나의 고유 URL을 가져야 한다.

고유식별자로 id필드를 사용한다. ListViewTest의 오래된 테스트를 수정한다. 예상했던 url설정 때문에 실패한다. 다행이다. url설정 이후 인수 문제로 실패한다. 수정후 우리가 원하는 리스트로 필터링 해준다.

#####새로운 세상으로 가기위한 new_list 수정

테스트가 새로운 url설정을 인식하지 못하고 있다. 테스트를 수정하면 뷰의 코드가 아직 수정되지 않았음을 알게된다. 이후 유닛테스트는 무시하 통과하지만 기능테스트는 실패하고 심지어 퇴행하게 된다.
 - ~~기능 테스트가 끝난 후에 결과물을 제거한다~~
 - ~~모델을 조정해서 아이템들이 다른 모곡과 연계되도록 한다~~
 - ~~각 목록별 고유 URL을 추가한다~~
 - ~~POST를 이용해서 새로운 목록을 생성하는 URL을 추가한다~~
 - POST를 이용해서 새로운 아이템을 기존 목록에 추가하는 URL을 만든다

---
###기존 목록에 아이템을 추가하기 위한 또 다른 뷰

현재 모든 POST 요청마다 새로운 목록을 만들기 때문에, 여러 아이템을 하나의 목록에 추가하는 기능이 동작하지 않는다. 

#####욕심 많은 정규표현식을 조심하자!

url에 정규표현식을 사용할 때는 그 범위를 잘 설정해야 한다. url에서 표현을 받을 때 숫자만 받을지 문자만 받을지 정하지 않으면 슬래쉬가 누락되어 url이 명확해지지 않는다.

#####마지막 신규 뷰

이제 익숙해 졌다. 새로운 뷰를 만든다. 

#####폼에서 URL을 사용하는 방법

{{ ... }} 구문으로 뷰에서 넣어준 변수를 사용할 수 있다. reverse lookup으로 외래키로 묶인 객체를 가져온다.
 - ~~기능 테스트가 끝난 후에 결과물을 제거한다~~
 - ~~모델을 조정해서 아이템들이 다른 모곡과 연계되도록 한다~~
 - ~~각 목록별 고유 URL을 추가한다~~
 - ~~POST를 이용해서 새로운 목록을 생성하는 URL을 추가한다~~
 - ~~POST를 이용해서 새로운 아이템을 기존 목록에 추가하는 URL을 만든다~~
 - urls.py 에 있는 중복 코드를 리팩터링한다.

---
###URL includes를 이용한 마지막 리팩토링

include 메서드를 이용해 url들을 리팩토링 해준다.
